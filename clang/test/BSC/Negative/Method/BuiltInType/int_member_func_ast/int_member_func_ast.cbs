// Test without serialization:
// RUN: %clang_cc1 -triple x86_64-unknown-unknown -ast-dump %s \
// RUN: | FileCheck --strict-whitespace %s
//
// Test with serialization:
// RUN: %clang_cc1 -triple x86_64-unknown-unknown -emit-pch -o %t %s
// RUN: %clang_cc1 -x bsc -triple x86_64-unknown-unknown -include-pch %t -ast-dump-all /dev/null \
// RUN: | sed -e "s/ <undeserialized declarations>//" -e "s/ imported//" \
// RUN: | FileCheck --strict-whitespace %s

void int::increase(int* this) {
    *this = *this +1;
}
// CHECK: BSCMethodDecl 0x{{[^ ]*}} parent 0x{{[^ ]*}} <{{.*}}:[[@LINE-3]]:1, line:[[@LINE-1]]:1> line:[[@LINE-3]]:11 used increase 'void (int *)'
// CHECK-NEXT: ParmVarDecl 0x{{[^ ]*}} <col:20, col:25> col:25 used this 'int *'
// CHECK-NEXT: CompoundStmt 0x{{[^ ]*}} <col:31, line:[[@LINE-3]]:1>
// CHECK-NEXT: BinaryOperator 0x{{[^ ]*}} <line:[[@LINE-5]]:5, col:20> 'int' '='
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <col:5, col:6> 'int' lvalue prefix '*' cannot overflow
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:6> 'int *' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:6> 'int *' lvalue ParmVar 0x{{[^ ]*}} 'this' 'int *'
// CHECK-NEXT: BinaryOperator 0x{{[^ ]*}} <col:13, col:20> 'int' '+'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:13, col:14> 'int' <LValueToRValue>
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <col:13, col:14> 'int' lvalue prefix '*' cannot overflow
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:14> 'int *' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:14> 'int *' lvalue ParmVar 0x{{[^ ]*}} 'this' 'int *'
// CHECK-NEXT: IntegerLiteral 0x{{[^ ]*}} <col:20> 'int' 1

int main() {
    int x = 1;
    int* y = &x;
    x.increase();
    y->increase();
    int::increase(y);
    return 0;
}
// CHECK: FunctionDecl 0x{{[^ ]*}} <line:[[@LINE-8]]:1, line:[[@LINE-1]]:1> line:[[@LINE-8]]:5 main 'int (void)'
// CHECK-NEXT: CompoundStmt 0x{{[^ ]*}} <col:12, line:[[@LINE-2]]:1>
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-9]]:5, col:14>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:5, col:13> col:9 used x 'int' cinit
// CHECK-NEXT: IntegerLiteral 0x{{[^ ]*}} <col:13> 'int' 1
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-11]]:5, col:16>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:5, col:15> col:10 used y 'int *' cinit
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <col:14, col:15> 'int *' prefix '&' cannot overflow
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:15> 'int' lvalue Var 0x{{[^ ]*}} 'x' 'int'
// CHECK-NEXT: CallExpr 0x{{[^ ]*}} <line:[[@LINE-14]]:5, col:16> 'void'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:5, col:7> 'void (*)(int *)' <FunctionToPointerDecay>
// CHECK-NEXT: MemberExpr 0x{{[^ ]*}} <col:5, col:7> 'void (int *)' lvalue .increase 0x{{[^ ]*}}
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:5> 'int' lvalue Var 0x{{[^ ]*}} 'x' 'int'
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <<invalid sloc>, col:5> 'int *' prefix '&' cannot overflow
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:5> 'int' lvalue Var 0x{{[^ ]*}} 'x' 'int'
// CHECK-NEXT: CallExpr 0x{{[^ ]*}} <line:[[@LINE-19]]:5, col:17> 'void'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:5, col:8> 'void (*)(int *)' <FunctionToPointerDecay>
// CHECK-NEXT: MemberExpr 0x{{[^ ]*}} <col:5, col:8> 'void (int *)' lvalue ->increase 0x{{[^ ]*}}
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:5> 'int *' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:5> 'int *' lvalue Var 0x{{[^ ]*}} 'y' 'int *'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:5> 'int *' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:5> 'int *' lvalue Var 0x{{[^ ]*}} 'y' 'int *'
// CHECK-NEXT: CallExpr 0x{{[^ ]*}} <line:[[@LINE-25]]:10, col:20> 'void'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:10> 'void (*)(int *)' <FunctionToPointerDecay>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:10> 'void (int *)' BSCMethod 0x{{[^ ]*}} 'increase' 'void (int *)'
// CHECK-NEXT: mplicitCastExpr 0x{{[^ ]*}} <col:19> 'int *' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:19> 'int *' lvalue Var 0x{{[^ ]*}} 'y' 'int *'
// CHECK-NEXT: ReturnStmt 0x{{[^ ]*}} <line:[[@LINE-29]]:5, col:12>
// CHECK-NEXT: IntegerLiteral 0x{{[^ ]*}} <col:12> 'int' 0