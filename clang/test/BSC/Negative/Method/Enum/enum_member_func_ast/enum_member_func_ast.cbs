// Test without serialization:
// RUN: %clang_cc1 -triple x86_64-unknown-unknown -ast-dump %s \
// RUN: | FileCheck --strict-whitespace %s
//
// Test with serialization:
// RUN: %clang_cc1 -triple x86_64-unknown-unknown -emit-pch -o %t %s
// RUN: %clang_cc1 -x bsc -triple x86_64-unknown-unknown -include-pch %t -ast-dump-all /dev/null \
// RUN: | sed -e "s/ <undeserialized declarations>//" -e "s/ imported//" \
// RUN: | FileCheck --strict-whitespace %s

enum E {
    X3,
    X4
};
// CHECK: EnumDecl 0x{{[^ ]*}} <{{.*}}:[[@LINE-4]]:1, line:[[@LINE-1]]:1> line:[[@LINE-4]]:6 E
// CHECK-NEXT: EnumConstantDecl 0x{{[^ ]*}} <line:[[@LINE-4]]:5> col:5 referenced X3 'int'
// CHECK-NEXT: EnumConstantDecl 0x{{[^ ]*}} <line:[[@LINE-4]]:5> col:5 referenced X4 'int'


typedef enum E F;
// CHECK: TypedefDecl 0x{{[^ ]*}} <line:[[@LINE-1]]:1, col:16> col:16 referenced F 'enum E':'enum E'
// CHECK-NEXT: ElaboratedType 0x{{[^ ]*}} 'enum E' sugar
// CHECK-NEXT: EnumType 0x{{[^ ]*}} 'enum E'
// CHECK-NEXT: Enum 0x{{[^ ]*}} 'E'

int F::getA(enum E* this) { 
  return X4;
}
// CHECK: BSCMethodDecl 0x{{[^ ]*}} parent 0x{{[^ ]*}} <line:[[@LINE-3]]:1, line:[[@LINE-1]]:1> line:[[@LINE-3]]:8 used getA 'int (enum E *)'
// CHECK-NEXT: ParmVarDecl 0x{{[^ ]*}} <col:13, col:21> col:21 this 'enum E *'
// CHECK-NEXT: CompoundStmt 0x{{[^ ]*}} <col:27, line:[[@LINE-3]]:1>
// CHECK-NEXT: ReturnStmt 0x{{[^ ]*}} <line:[[@LINE-5]]:3, col:10>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:10> 'int' EnumConstant 0x{{[^ ]*}} 'X4' 'int'

int main() {
  F foo = X3; 
  enum E* f = &foo;
  foo.getA();
  int x = f->getA();
  enum E::getA(f);
  return 0;
}
// CHECK: FunctionDecl 0x{{[^ ]*}} <line:[[@LINE-8]]:1, line:[[@LINE-1]]:1> line:[[@LINE-8]]:5 main 'int (void)'
// CHECK-NEXT: CompoundStmt 0x{{[^ ]*}} <col:12, line:[[@LINE-2]]:1>
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-9]]:3, col:13>
// CHECK-NEXT: arDecl 0x{{[^ ]*}} <col:3, col:11> col:5 used foo 'F':'enum E' cinit
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:11> 'F':'enum E' <IntegralCast>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:11> 'int' EnumConstant 0x{{[^ ]*}} 'X3' 'int'
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-12]]:3, col:19>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:16> col:11 used f 'enum E *' cinit
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <col:15, col:16> 'F *' prefix '&' cannot overflow
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:16> 'F':'enum E' lvalue Var 0x{{[^ ]*}} 'foo' 'F':'enum E'
// CHECK-NEXT: CallExpr 0x{{[^ ]*}} <line:[[@LINE-15]]:3, col:12> 'int'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:3, col:7> 'int (*)(enum E *)' <FunctionToPointerDecay>
// CHECK-NEXT: MemberExpr 0x{{[^ ]*}} <col:3, col:7> 'int (enum E *)' lvalue .getA 0x{{[^ ]*}}
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:3> 'F':'enum E' lvalue Var 0x{{[^ ]*}} 'foo' 'F':'enum E'
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <<invalid sloc>, col:3> 'enum E *' prefix '&' cannot overflow
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:3> 'F':'enum E' lvalue Var 0x{{[^ ]*}} 'foo' 'F':'enum E'
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-20]]:3, col:20>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:19> col:7 x 'int' cinit
// CHECK-NEXT: CallExpr 0x{{[^ ]*}} <col:11, col:19> 'int'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:11, col:14> 'int (*)(enum E *)' <FunctionToPointerDecay>
// CHECK-NEXT: MemberExpr 0x{{[^ ]*}} <col:11, col:14> 'int (enum E *)' lvalue ->getA 0x{{[^ ]*}}
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:11> 'enum E *' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:11> 'enum E *' lvalue Var 0x{{[^ ]*}} 'f' 'enum E *'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:11> 'enum E *' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:11> 'enum E *' lvalue Var 0x{{[^ ]*}} 'f' 'enum E *'
// CHECK-NEXT: CallExpr 0x{{[^ ]*}} <line:[[@LINE-28]]:11, col:17> 'int'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:11> 'int (*)(enum E *)' <FunctionToPointerDecay>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:11> 'int (enum E *)' BSCMethod 0x{{[^ ]*}} 'getA' 'int (enum E *)'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:16> 'enum E *' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:16> 'enum E *' lvalue Var 0x{{[^ ]*}} 'f' 'enum E *'
// CHECK-NEXT: ReturnStmt 0x{{[^ ]*}} <line:[[@LINE-32]]:3, col:10>
// CHECK-NEXT: IntegerLiteral 0x{{[^ ]*}} <col:10> 'int' 0