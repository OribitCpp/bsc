// Test without serialization:
// RUN: %clang_cc1 -triple x86_64-unknown-unknown -ast-dump %s \
// RUN: | FileCheck --strict-whitespace %s
//
// Test with serialization:
// RUN: %clang_cc1 -triple x86_64-unknown-unknown -emit-pch -o %t %s
// RUN: %clang_cc1 -x bsc -triple x86_64-unknown-unknown -include-pch %t -ast-dump-all /dev/null \
// RUN: | sed -e "s/ <undeserialized declarations>//" -e "s/ imported//" \
// RUN: | FileCheck --strict-whitespace %s

union SimpleUnion {
  float uf;
  int ui;
};
// CHECK: RecordDecl 0x{{[^ ]*}} <{{.*}}:[[@LINE-4]]:1, line:[[@LINE-1]]:1> line:[[@LINE-4]]:7 union SimpleUnion definition
// CHECK-NEXT: FieldDecl 0x{{[^ ]*}} <line:[[@LINE-4]]:3, col:9> col:9 uf 'float'
// CHECK-NEXT: FieldDecl 0x{{[^ ]*}} <line:[[@LINE-4]]:3, col:7> col:7 referenced ui 'int'

int union SimpleUnion::getA(union SimpleUnion * this) { 
  return this->ui;
}
// CHECK: BSCMethodDecl 0x{{[^ ]*}} parent 0x{{[^ ]*}} <line:[[@LINE-3]]:1, line:[[@LINE-1]]:1> line:[[@LINE-3]]:24 used getA 'int (union SimpleUnion *)'
// CHECK-NEXT: ParmVarDecl 0x{{[^ ]*}} <col:29, col:49> col:49 used this 'union SimpleUnion *'
// CHECK-NEXT: CompoundStmt 0x{{[^ ]*}} <col:55, line:[[@LINE-3]]:1>
// CHECK-NEXT: ReturnStmt 0x{{[^ ]*}} <line:[[@LINE-5]]:3, col:16>
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:10, col:16> 'int' <LValueToRValue>
// CHECK-NEXT: MemberExpr 0x{{[^ ]*}} <col:10, col:16> 'int' lvalue ->ui 0x{{[^ ]*}}
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:10> 'union SimpleUnion *' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:10> 'union SimpleUnion *' lvalue ParmVar 0x{{[^ ]*}} 'this' 'union SimpleUnion *'

int main() {
  union SimpleUnion foo = {.ui = 1};
  union SimpleUnion* f = &foo;
  foo.getA();
  f->getA();
  union SimpleUnion::getA(&foo);
  return 0;
}
// CHECK: FunctionDecl 0x{{[^ ]*}} <line:[[@LINE-8]]:1, line:[[@LINE-1]]:1> line:[[@LINE-8]]:5 main 'int (void)'
// CHECK-NEXT: CompoundStmt 0x{{[^ ]*}} <col:12, line:[[@LINE-2]]:1>
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-9]]:3, col:36>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:35> col:21 used foo 'union SimpleUnion':'union SimpleUnion' cinit
// CHECK-NEXT: InitListExpr 0x{{[^ ]*}} <col:27, col:35> 'union SimpleUnion':'union SimpleUnion' field Field 0x{{[^ ]*}} 'ui' 'int'
// CHECK-NEXT: IntegerLiteral 0x{{[^ ]*}} <col:34> 'int' 1
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-12]]:3, col:30>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:27> col:22 used f 'union SimpleUnion *' cinit
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <col:26, col:27> 'union SimpleUnion *' prefix '&' cannot overflow
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:27> 'union SimpleUnion':'union SimpleUnion' lvalue Var 0x{{[^ ]*}} 'foo' 'union SimpleUnion':'union SimpleUnion'
// CHECK-NEXT: CallExpr 0x{{[^ ]*}} <line:[[@LINE-15]]:3, col:12> 'int'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:3, col:7> 'int (*)(union SimpleUnion *)' <FunctionToPointerDecay>
// CHECK-NEXT: MemberExpr 0x{{[^ ]*}} <col:3, col:7> 'int (union SimpleUnion *)' lvalue .getA 0x{{[^ ]*}}
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:3> 'union SimpleUnion':'union SimpleUnion' lvalue Var 0x{{[^ ]*}} 'foo' 'union SimpleUnion':'union SimpleUnion'
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <<invalid sloc>, col:3> 'union SimpleUnion *' prefix '&' cannot overflow
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:3> 'union SimpleUnion':'union SimpleUnion' lvalue Var 0x{{[^ ]*}} 'foo' 'union SimpleUnion':'union SimpleUnion'
// CHECK-NEXT: CallExpr 0x{{[^ ]*}} <line:[[@LINE-20]]:3, col:11> 'int'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:3, col:6> 'int (*)(union SimpleUnion *)' <FunctionToPointerDecay>
// CHECK-NEXT: MemberExpr 0x{{[^ ]*}} <col:3, col:6> 'int (union SimpleUnion *)' lvalue ->getA 0x{{[^ ]*}}
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:3> 'union SimpleUnion *' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:3> 'union SimpleUnion *' lvalue Var 0x{{[^ ]*}} 'f' 'union SimpleUnion *'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:3> 'union SimpleUnion *' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:3> 'union SimpleUnion *' lvalue Var 0x{{[^ ]*}} 'f' 'union SimpleUnion *'
// CHECK-NEXT: CallExpr 0x{{[^ ]*}} <line:[[@LINE-26]]:22, col:31> 'int'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:22> 'int (*)(union SimpleUnion *)' <FunctionToPointerDecay>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:22> 'int (union SimpleUnion *)' BSCMethod 0x{{[^ ]*}} 'getA' 'int (union SimpleUnion *)'
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <col:27, col:28> 'union SimpleUnion *' prefix '&' cannot overflow
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:28> 'union SimpleUnion':'union SimpleUnion' lvalue Var 0x{{[^ ]*}} 'foo' 'union SimpleUnion':'union SimpleUnion'
// CHECK-NEXT: ReturnStmt 0x{{[^ ]*}} <line:[[@LINE-30]]:3, col:10>
// CHECK-NEXT: IntegerLiteral 0x{{[^ ]*}} <col:10> 'int' 0