// RUN: %clang_cc1 -ast-dump -verify %s

struct R {
   int num;
};

int f() { return 2; }
int test() {
  int arr[3] = {1, 2, 3};
  int * borrow p1 = &mut arr[0];
  // unary *
  *p1 += 1; // legal

  // == ï¼= > < <= >=
  int a = 1;
  float b = 1.0;
  int * p2 = &a;
  int *borrow  p3 = &mut a;
  int *borrow  p4 = &mut a;
  const int *borrow p5 = &const a;
  const int *borrow p6 = &const a;
  float *borrow p7 = &mut b;
  if (p3 == p4) {} // legal
  if (p5 != p6) {} // legal
  if (p3 == p5) {} // expected-error {{incompatible borrow types, 'const int *borrow' and 'int *borrow' cannot be compared}}
  if (p3 == p7) {} // expected-error {{incompatible borrow types, 'float *borrow' and 'int *borrow' cannot be compared}}
  if (p3 >= &mut a) {} // legal
  if (p5 < &a) {} // expected-error {{incompatible borrow types, 'int *' and 'const int *borrow' cannot be compared}}

  if (sizeof(int * borrow) != sizeof(int *)) { return 1; }
  if (_Alignof(int * borrow) != _Alignof(int *)) { return 1; }

  int (* borrow p8)() = &mut f; // expected-error {{'&mut' for function pointer is not allowed}}
  int (* const borrow p9)() = &const f; // legal
  a = p9();

  // ! && ||
  _Bool b1 = !p1;
  _Bool b2 = !p3;
  b1 = !p2 && p3 || p5;
  b1 = p4 || p5;
  b1 = p4 && p5;

  // ->
  struct R r = { .num = 1 };
  struct R * borrow p10 = &mut r;
  a = p10->num;

  // unsupport
  p1[1] += 1; // expected-error {{subscript of borrow pointer is not allowed}}
  -p3; // expected-error {{invalid argument type 'int *borrow' to unary expression}}
  -p5; // expected-error {{invalid argument type 'const int *borrow' to unary expression}}
  p3 * p4; // expected-error {{invalid operands to binary expression ('int *borrow' and 'int *borrow')}}
  p3 / p4; // expected-error {{invalid operands to binary expression ('int *borrow' and 'int *borrow')}}
  p5 % p6; // expected-error {{invalid operands to binary expression ('const int *borrow' and 'const int *borrow')}}
  p5 & p6; // expected-error {{invalid operands to binary expression ('const int *borrow' and 'const int *borrow')}}
  p3 | p4; // expected-error {{invalid operands to binary expression ('int *borrow' and 'int *borrow')}}
  ~p3; // expected-error {{invalid argument type 'int *borrow' to unary expression}}
  ~p5; // expected-error {{invalid argument type 'const int *borrow' to unary expression}}
  p5 << 6; // expected-error {{invalid operands to binary expression ('const int *borrow' and 'int')}}
  p3 >> p4; // expected-error {{invalid operands to binary expression ('int *borrow' and 'int *borrow')}}
  &mut p3; // expected-error {{'&mut' on a 'borrow' quialified type is not allowed}}
           // expected-warning@-1 {{expression result unused}}
  &mut p5; // expected-error {{'&mut' on a 'borrow' quialified type is not allowed}}
           // expected-warning@-1 {{expression result unused}}
  &const p3; // expected-error {{'&const' on a 'borrow' quialified type is not allowed}}
             // expected-warning@-1 {{expression result unused}}
  &const p5; // expected-error {{'&const' on a 'borrow' quialified type is not allowed}}
             // expected-warning@-1 {{expression result unused}}

  // unary -- ++
  p3++; // expected-error {{invalid argument type 'int *borrow' to unary expression}}
  --p3; // expected-error {{invalid argument type 'int *borrow' to unary expression}}
  p5--; // expected-error {{invalid argument type 'const int *borrow' to unary expression}}
  ++p5; // expected-error {{invalid argument type 'const int *borrow' to unary expression}}

  // binary - +
  a = *p3 + *p5;
  p3 + p5; // expected-error {{invalid operands to binary expression ('int *borrow' and 'const int *borrow')}}
  p3 = p3 + 1; // expected-error {{invalid operands to binary expression ('int *borrow' and 'int')}}
  p5 = p5 - 1; // expected-error {{nvalid operands to binary expression ('const int *borrow' and 'int')}}
  return 0;
}