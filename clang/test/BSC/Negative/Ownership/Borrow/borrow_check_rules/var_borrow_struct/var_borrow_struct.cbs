// RUN: %clang_cc1 -verify %s

typedef struct S {
  int a;
  int b;
} S;

void use_mut(S *borrow s);
void use_const(const S *borrow s);
T *owned safe_malloc<T>(T value);
void free_owned<T>(T *owned p);
void free(void*);

void test1() {
  S s = { .a = 1, .b = 2 };
  S *borrow p = &mut s; // expected-note {{first mut borrow occurs here}}
  S *borrow q = &mut s; // expected-error {{cannot borrow `s` as mutable more than once at a time}}
  use_mut(p);
  use_mut(q);
}

void test2() {
  S tmp = {.a = 1, .b = 2};
  S *owned oriPtr = safe_malloc<S>(tmp);
  S *borrow p1 = &mut *oriPtr; // expected-note {{first mut borrow occurs here}}
  S *borrow p2 = &mut *oriPtr; // expected-error {{cannot borrow `*oriPtr` as mutable more than once at a time}}
  use_mut(p1);
  use_mut(p2);
  free_owned<S>(oriPtr);
}

void test3(S *oriPtr) {
  S *borrow p1 = &mut *oriPtr; // expected-note {{first mut borrow occurs here}}
  S *borrow p2 = &mut *oriPtr; // expected-error {{cannot borrow `*oriPtr` as mutable more than once at a time}}
  use_mut(p1);
  free(oriPtr);
}

void test4() {
  S local = { .a = 1, .b = 2 };
  S *borrow p = &mut local; // expected-note {{first mut borrow occurs here}}
  S *borrow p1 = &mut local; // expected-error {{cannot borrow `local` as mutable more than once at a time}}
  const S *borrow p2 = &const *p; // expected-note {{immutable borrow occurs here}}
  use_mut(p); // expected-error {{cannot borrow `*p` as mutable because it is also borrowed as immutable}}
  use_mut(p1);
  use_const(p2);
}

void test5() {
  S local = { .a = 1, .b = 2 };
  S *borrow p1 = &mut local; // expected-note {{mutable borrow occurs here}}
  const S *borrow p2 = &const local; // expected-error {{cannot borrow `local` as immutable because it is also borrowed as mutable}}
  use_mut(p1);
  use_const(p2);
}

void test6(S *borrow p) {
  S local = { .a = 1, .b = 2 };
  p = &mut local;
  const S *borrow p1 = &const *p; // expected-note {{immutable borrow occurs here}}
  use_mut(p); // expected-error {{cannot borrow `*p` as mutable because it is also borrowed as immutable}}
  use_const(p1);
}

void test7(S *borrow p) {
  S *borrow p1 = p; // expected-note {{`*p` is borrowed here}}
                    // expected-note@-1 {{first mut borrow occurs here}}
  use_mut(p); // expected-error {{cannot use `p` because it was mutably borrowed}}
              // expected-error@-1 {{cannot borrow `*p` as mutable more than once at a time}}
  use_mut(p1);
}

void test8() {
  S local = { .a = 1, .b = 2 };
  S *borrow p = &mut local; // expected-note {{`local.b` is borrowed here}}
  local.b = 3; // expected-error {{cannot assign to `local.b` because it is borrowed}}
  use_mut(p);
}

void test9() {
  S local = { .a = 1, .b = 2};
  const S *borrow p = &const local; // expected-note {{`local.b` is borrowed here}}
  local.b = 3; // expected-error {{cannot assign to `local.b` because it is borrowed}}
  use_const(p);
}

void test10() {
  S local = { .a = 1, .b = 2 };
  S *borrow p = &mut local; // expected-note {{`local` is borrowed here}}
  int x = local.b; // expected-error {{cannot use `local.b` because it was mutably borrowed}}
  use_mut(p);
}

void test11() {
  S local = { .a = 1, .b = 2 };
  int *borrow p1 = &mut local.a; // expected-note {{`local.a` is borrowed here}}
  local.a = 5; // expected-error {{cannot assign to `local.a` because it is borrowed}}
  int *borrow p2 = p1;
}

void test12() {
  S foo = { .a = 1, .b = 2 };
  S *borrow p = &mut foo;
  use_mut(p);
  S temp = foo;
}