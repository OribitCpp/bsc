// RUN: %clang_cc1 -fsyntax-only -verify %s

struct MyStruct<T> {
  T res;
};

safe T struct MyStruct<T>::foo_a(T a) {
  return a;
}

safe T struct MyStruct<T>::foo_b(T a) {      // expected-error{{unsafe return type is forbidden in the safe function}}
                                             // expected-error@-1{{unsafe parameter type is forbidden in the safe function}}
  return a;
}

safe void struct MyStruct<T>::foo_c(T a) {
  a();                                       // expected-error{{unsafe function call is forbidden in the safe zone}}
  unsafe {
    a();
  }
}

typedef void (*unsafeFun)(void);

void genericMemberFun() {
  int a = 1;
  int* owned p = (int* owned)&a;
  int *q = (void*)0;
  int res1 = struct MyStruct<int>::foo_a(12); // OK
  int* owned m = struct MyStruct<int* owned>::foo_a(p);   // OK 
  int *n = struct MyStruct<int*>::foo_b(q);  // expected-note{{in instantiation of member function 'MyStruct<int *>::foo_b' requested here}}
  unsafeFun fun_c;
  struct MyStruct<unsafeFun>::foo_c(fun_c);  // expected-note{{in instantiation of member function 'MyStruct<void (*)(void)>::foo_c' requested here}}
}// expected-error {{memory leak of value: `m`}}

trait F<T> {
  safe int foo(This* owned this, T b);
};

safe int int::foo(int* owned this, int *b) {  // expected-error{{unsafe parameter type is forbidden in the safe function}}
  return 0;
}

impl trait F<int *> for int;

trait G<T> {
  int goo(This* this, T b);
};

int int::goo(int* this, int *b) {  // OK
  return 0;
}

impl trait G<int *> for int;