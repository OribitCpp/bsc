// RUN: %clang %s %S/scheduler.cbs %S/noise.cbs -o %test.output -lpthread
// RUN: %clang -rewrite-bsc %s -o %t-rw.c
// RUN: %clang -rewrite-bsc %S/scheduler.cbs -o %T/scheduler.c
// RUN: %clang -rewrite-bsc %S/noise.cbs -o %T/noise.c
// RUN: %clang %t-rw.c %T/scheduler.c %T/noise.c -o %t-rw.output -lpthread
// expected-no-diagnostics

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <time.h>
#include "scheduler.hbs"

#define ROW 50
#define COL 50
#define BUFFER_SIZE 1024

NOISE g_noise;

typedef struct FileWriter {
    FILE *file;
    char *buffer;
    _Bool isWrited;
}FileWriter;

FileWriter fileWriter(FILE *file, char *buffer) {
    struct FileWriter fw;
    fw.file = file;
    fw.buffer = buffer;
    fw.isWrited = false;
    return fw;
}

struct PollResult<struct Void> FileWriter::poll(FileWriter *this) {
    if (this->isWrited) {
        this->isWrited = false;
        struct Void res = {};
        return struct PollResult<struct Void>::completed(res);
    } else {
        //TODO: Change to asynchronous IO
        if (fprintf(this->file,  "%s", this->buffer) < 0) {
            perror("file writer failed");
        }
        this->isWrited = true;
        return struct PollResult<struct Void>::pending();
    }
}

void FileWriter::free(FileWriter *this) {}

impl trait Future<struct Void> for FileWriter;

async void createMatrix(int matrix[ROW][COL]) {
    int i, j, k = 0;

    srand((unsigned)time(NULL));
    for (i = 0; i < ROW; i++) {
        for (j = 0; j < COL; j++) {
            matrix[i][j] = rand() %2;
        }
    }
}

async void multiMatrix(int matrix1[ROW][COL], int matrix2[ROW][COL], int result[ROW][COL]) {
    for (int i = 0; i < ROW; i++) {
        for (int j = 0; j < COL; j++) {
            int sum = 0;
            for (int k = 0; k < COL; k++) {
                sum += matrix1[i][k] * matrix2[k][j];
            }
            result[i][j] = sum;
        }
    }
}

async void matrixCalculation() {
    char str[COL + 2];
    int matrix1[ROW][COL];
    int matrix2[ROW][COL];
    int result[ROW][COL];
    char buffer[BUFFER_SIZE] = {0};

    await createMatrix(matrix1);
    await createMatrix(matrix2);
    await multiMatrix(matrix1, matrix2, result);

    FILE *file = fopen("./matrix.txt", "w");
    if (file == NULL) {
        perror("error opening file\n");
        fclose(file);
    }

    int k = 0;
    for (int i = 0; i < ROW; i++) {
        for (int j = 0; j < COL; j++) {
            k += sprintf(&str[k], "%d ", result[i][j]);
        }
        str[k++] = '\0';
        await fileWriter(file, buffer);
        k = 0;
    }

    struct Scheduler::destroy();
}

int main() {
    g_noise.init();
    uint64_t start, end;
    start = read_tsc();
    struct Scheduler::init(4);
    end = read_tsc();
    g_noise.initCost = end - start;

    struct Scheduler::spawn(matrixCalculation());

    struct Scheduler::run();


    // 协程基础设施
    if (g_noise.initCost > 0)
        printf("scheduler init cost: %lu\n", g_noise.initCost); // 初始化调度器
    if (g_noise.createTaskCost > 0)
        printf("scheduler creat async task cost: %lu\n", g_noise.createTaskCost / g_noise.createTaskCount); // 创建异步任务
    if (g_noise.freeCount > 0)
        printf("scheduler free cost: %lu\n", g_noise.freeCost / g_noise.freeCount); // 销毁异步任务
    if (g_noise.pushCost > 0)
        printf("scheduler push cost: %lu\n", g_noise.pushCost / g_noise.pushCount); // 放入队列
    if (g_noise.popCost > 0)
        printf("scheduler pop cost: %lu\n", g_noise.popCost / g_noise.popCount); // 从队列中取出

    // 调度策略
    if (g_noise.getTaskCount > 0 && g_noise.popCount > 0)
        printf("scheduler get task cost: %lu\n", (g_noise.getTaskCost / g_noise.getTaskCount) - (g_noise.popCost / g_noise.popCount)); // 选择任务

    return 0;
}



