// Test without serialization:
// RUN: %clang_cc1 -triple x86_64-unknown-unknown -ast-dump %s \
// RUN: | FileCheck --strict-whitespace %s

struct Foo {
  int a;
};

T* owned safe_malloc<T>(T value);
void free_owned<T>(T* owned p);


int struct Foo::getB(This* this) {
  this->a = 3;
  return this->a;
}

int struct Foo::getB_2(const This* this) {
  return this->a;
}

safe int struct Foo::getC(This* borrow this) {
  this->a = 2;
  return this->a;
}

safe int struct Foo::getC_2(const This* borrow this) {
  return this->a;
}

safe void struct Foo::getD(This* owned this) {
  free_owned<struct Foo>(this);
}

void test_non_pointer_This_call_reborrow() {
  struct Foo foo = {.a = 1};
  safe {
    int c = foo.getC();
    int c_2 = foo.getC_2();
  }
}
// CHECK: DeclStmt 0x{{[^ ]*}} <line:{{.*}}:5, col:23>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:5, col:22> col:9 c 'int' cinit
// CHECK-NEXT: CallExpr 0x{{[^ ]*}} <col:13, col:22> 'int'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:13, col:17> 'int (*)(struct Foo *borrow)' safe <FunctionToPointerDecay>
// CHECK-NEXT: MemberExpr 0x{{[^ ]*}} <col:13, col:17> 'int (struct Foo *borrow)' safe lvalue .getC
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:13> 'struct Foo':'struct Foo' lvalue Var 0x{{[^ ]*}} 'foo' 'struct Foo':'struct Foo'
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <<invalid sloc>, col:13> 'struct Foo *borrow' prefix '&mut' cannot overflow
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:13> 'struct Foo':'struct Foo' lvalue Var 0x{{[^ ]*}} 'foo' 'struct Foo':'struct Foo'

// CHECK: DeclStmt 0x{{[^ ]*}} <line:{{.*}}:5, col:27>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:5, col:26> col:9 c_2 'int' cinit
// CHECK-NEXT: CallExpr 0x{{[^ ]*}} <col:15, col:26> 'int'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:15, col:19> 'int (*)(const struct Foo *borrow)' safe <FunctionToPointerDecay>
// CHECK-NEXT: MemberExpr 0x{{[^ ]*}} <col:15, col:19> 'int (const struct Foo *borrow)' safe lvalue .getC_2 0x{{[^ ]*}}
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:15> 'struct Foo':'struct Foo' lvalue Var 0x{{[^ ]*}} 'foo' 'struct Foo':'struct Foo'
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <<invalid sloc>, col:15> 'const struct Foo *borrow' prefix '&const' cannot overflow
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:15> 'struct Foo':'struct Foo' lvalue Var 0x{{[^ ]*}} 'foo' 'struct Foo':'struct Foo'


void test_const_raw_pointer_call_reborrow() {
  struct Foo foo = {.a = 1};
  const struct Foo* c_foo_p = &foo;
  int b_2 = c_foo_p->getB_2();
  int c_2 = c_foo_p->getC_2();
}
// CHECK: DeclStmt 0x{{[^ ]*}} <line:{{.*}}:3, col:30>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:29> col:7 b_2 'int' cinit
// CHECK-NEXT: CallExpr 0x{{[^ ]*}} <col:13, col:29> 'int'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:13, col:22> 'int (*)(const struct Foo *)' <FunctionToPointerDecay>
// CHECK-NEXT: MemberExpr 0x{{[^ ]*}} <col:13, col:22> 'int (const struct Foo *)' lvalue ->getB_2 0x{{[^ ]*}}
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:13> 'const struct Foo *' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:13> 'const struct Foo *' lvalue Var 0x{{[^ ]*}} 'c_foo_p' 'const struct Foo *'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:13> 'const struct Foo *' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:13> 'const struct Foo *' lvalue Var 0x{{[^ ]*}} 'c_foo_p' 'const struct Foo *'

// CHECK: DeclStmt 0x{{[^ ]*}} <line:{{.*}}:3, col:30>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:29> col:7 c_2 'int' cinit
// CHECK-NEXT: CallExpr 0x{{[^ ]*}} <col:13, col:29> 'int'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:13, col:22> 'int (*)(const struct Foo *borrow)' safe <FunctionToPointerDecay>
// CHECK-NEXT: MemberExpr 0x{{[^ ]*}} <col:13, col:22> 'int (const struct Foo *borrow)' safe lvalue ->getC_2 0x{{[^ ]*}}
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:13> 'const struct Foo *' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:13> 'const struct Foo *' lvalue Var 0x{{[^ ]*}} 'c_foo_p' 'const struct Foo *'
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <<invalid sloc>, col:13> 'const struct Foo *borrow' prefix '&const *' cannot overflow
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:13> 'const struct Foo *' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:13> 'const struct Foo *' lvalue Var 0x{{[^ ]*}} 'c_foo_p' 'const struct Foo *'

void test_owned_pointer_call_reborrow() {
  struct Foo foo = {.a = 1};
  struct Foo * owned foo_owned = safe_malloc<struct Foo>(foo);
  int b = foo_owned->getB();
  int b_2 = foo_owned->getB_2();
  safe {
    int c = foo_owned->getC();
    int c_2 = foo_owned->getC_2();
    foo_owned->getD();
  }
}
// CHECK: DeclStmt 0x{{[^ ]*}} <line:{{.*}}:5, col:30>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:5, col:29> col:9 c 'int' cinit
// CHECK-NEXT: CallExpr 0x{{[^ ]*}} <col:13, col:29> 'int'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:13, col:24> 'int (*)(struct Foo *borrow)' safe <FunctionToPointerDecay>
// CHECK-NEXT: MemberExpr 0x{{[^ ]*}} <col:13, col:24> 'int (struct Foo *borrow)' safe lvalue ->getC 0x{{[^ ]*}}
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:13> 'struct Foo *owned' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:13> 'struct Foo *owned' lvalue Var 0x{{[^ ]*}} 'foo_owned' 'struct Foo *owned'
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <<invalid sloc>, col:13> 'struct Foo *borrow' prefix '&mut *' cannot overflow
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:13> 'struct Foo *owned' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:13> 'struct Foo *owned' lvalue Var 0x{{[^ ]*}} 'foo_owned' 'struct Foo *owned'

// CHECK: DeclStmt 0x{{[^ ]*}} <line:{{.*}}:5, col:34>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:5, col:33> col:9 c_2 'int' cinit
// CHECK-NEXT: CallExpr 0x{{[^ ]*}} <col:15, col:33> 'int'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:15, col:26> 'int (*)(const struct Foo *borrow)' safe <FunctionToPointerDecay>
// CHECK-NEXT: MemberExpr 0x{{[^ ]*}} <col:15, col:26> 'int (const struct Foo *borrow)' safe lvalue ->getC_2 0x{{[^ ]*}}
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:15> 'struct Foo *owned' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:15> 'struct Foo *owned' lvalue Var 0x{{[^ ]*}} 'foo_owned' 'struct Foo *owned'
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <<invalid sloc>, col:15> 'const struct Foo *borrow' prefix '&const *' cannot overflow
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:15> 'struct Foo *owned' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:15> 'struct Foo *owned' lvalue Var 0x{{[^ ]*}} 'foo_owned' 'struct Foo *owned'
