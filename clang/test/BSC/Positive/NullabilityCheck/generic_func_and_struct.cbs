// RUN: %clang %s -o %t.output
// RUN: %t.output
// RUN: %clang -rewrite-bsc %s -o %t-rw.c
// RUN: %clang %t-rw.c -o %t-rw.output
// RUN: %t-rw.output
// expected-no-diagnostics

#include <stdlib.h>
safe T *owned safe_malloc<T>(T t) {
    unsafe {
        T *addr = (T *)malloc(sizeof(T));
        if (!addr) {
            addr = &t;
            T* forget = &t;
            *forget = t;
            exit(EXIT_FAILURE);
        } else {
            *addr = t;
        }
        return (T *owned)addr;
    }
}
safe void use<T>(T *borrow p) {}

owned struct Data<T> {
public:
    T *owned _Nullable p1;
    T *owned p2;
    ~Data(This this) {
        free((void*)this.p2);
        if (this.p1 != nullptr)
            free((void*)this.p1);
    }
};

safe Data<T> Data<T>::init(T a) {
    T *owned _Nullable data1 = nullptr;
    T *owned data2 = safe_malloc<T>(a);
    Data<T> data = { .p1 = data1, .p2 = data2 };
    return data;
}

owned struct BorrowData<T> {
public:
    Data<T> *borrow _Nullable p1;
    Data<T> *borrow p2;
};

safe int main(void) {
    Data<int> data1 = Data<int>::init(5);
    if (data1.p1 != nullptr) {
        use(&mut *(data1.p1));
    }
    use(&mut *(data1.p2));

    Data<int> data2 = Data<int>::init(5);
    BorrowData<int> borrow_data = { .p1 = nullptr, .p2 = &mut data2 };
    if (borrow_data.p1 != nullptr) {
        if (borrow_data.p1->p1 != nullptr) {
          use(&mut *(borrow_data.p1->p1));
        }
    }
    use(&mut *(borrow_data.p2->p2));
    return 0;
}