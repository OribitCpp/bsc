// RUN: %clang %s -o %t.output
// RUN: %t.output
// RUN: %clang -rewrite-bsc %s -o %t-rw.c
// RUN: %clang %t-rw.c -o %t-rw.output
// RUN: %t-rw.output
// expected-no-diagnostics

#include <stdio.h>

trait F<T> {
  T f(This* this);
};

int int::f(int* this) {
  return 1;
}

struct S<T> {
  int num;
  trait F<T>* future;
  char c;
};

struct S1<T> {
  struct S<T> s;
};

impl trait F<int> for int;

int main() {
  int x = 1;
  trait F<int> *r = &x;
  struct S<int> s = { .future = &x, .c = 'c'};
  struct S<int> s1 = { .future = (trait F<int>*)&x };
  struct S<int> s2 = { 1, &x, 'c' };
  struct S<int> s3 = { 1, (trait F<int>*)&x, 'c' };
  struct S<int> s4 = { .future = r };
  struct S<int> s5;
  s5.future = &x;
  int a = s.future->f();
  int a1 = s1.future->f();
  int a2 = s2.future->f();
  int a3 = s3.future->f();
  int a4 = s4.future->f();
  int a5 = s5.future->f();

  struct S1<int> s6 = { .s.future = &x };
  struct S1<int> s7 = { .s.num = 1, .s.future = (trait F<int>*)&x };
  struct S1<int> s8 = { s };
  struct S1<int> s9 = { {1, &x, 'c'} };
  struct S1<int> s10 = { {1, (trait F<int>*)&x, 'c'} };
  struct S1<int> s11 = { .s.num = 1, .s.future = r, .s.c = 'c' };
  int b = s6.s.future->f();
  int b1 = s7.s.future->f();
  int b2 = s8.s.future->f();
  int b3 = s9.s.future->f();
  int b4 = s10.s.future->f();
  int b5 = s11.s.future->f();

  struct S<int> s12 = { 1, .future = &x, 'c' };
  struct S<int> s13 = { .num = 1, &x, .c = 'c' };
  struct S<int> s14 = { 1, NULL, 'c' };
  struct S<int> s15 = { 1, .future = NULL, 'c' };
  struct S<int> s16 = { .num = 1, .future = NULL, .c = 'c' };
  struct S<int> s17;
  s17.future = NULL;

  return a + a1 + a2 + a3 + a4 + a5 - b -b1 -b2 -b3 -b4 -b5;
}