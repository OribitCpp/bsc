// RUN: %clang %s -o %test.output
// RUN: %test.output
// RUN: %clang -rewrite-bsc %s -o %t-rw.c
// RUN: FileCheck --input-file=%t-rw.c %s
// RUN: %clang %t-rw.c -o %t-rw.output
// RUN: %t-rw.output
// expected-no-diagnostics

// custom type
struct E
{
    int a;
};

__attribute__((operator ~))
int opratorAnd1(struct E f1){
    return ~f1.a;
}

int genericAnd1<T>(T a) {
    return ~a;
}

int test1(){
    struct E f1 = {1};
    if ((~f1) != -2) {
        return -1;
    }
    if (genericAnd1(f1) != -2) {
        return -1;
    }
    return 0;
}

int main(){
    if (test1()) {
        return -1;
    }

    return 0;
}

// CHECK:      struct E;
// CHECK:      struct E
// CHECK-NEXT: {
// CHECK-NEXT:     int a;
// CHECK-NEXT: };
// CHECK-EMPTY:
// CHECK:      static int genericAnd1_struct_E(struct E a);
// CHECK-EMPTY:
// CHECK:      int opratorAnd1(struct E f1) {
// CHECK-NEXT:     return ~f1.a;
// CHECK-NEXT: }
// CHECK-EMPTY:
// CHECK:      int test1(void) {
// CHECK-NEXT:     struct E f1 = {1};
// CHECK-NEXT:     if ((opratorAnd1(f1)) != -2) {
// CHECK-NEXT:         return -1;
// CHECK-NEXT:     }
// CHECK-NEXT:     if (genericAnd1_struct_E(f1) != -2) {
// CHECK-NEXT:         return -1;
// CHECK-NEXT:     }
// CHECK-NEXT:     return 0;
// CHECK-NEXT: }
// CHECK-EMPTY:
// CHECK:      int main(){
// CHECK-NEXT:     if (test1()) {
// CHECK-NEXT:         return -1;
// CHECK-NEXT:     }
// CHECK-EMPTY:
// CHECK-NEXT:     return 0;
// CHECK-NEXT: }
// CHECK-EMPTY:
// CHECK:      static int genericAnd1_struct_E(struct E a) {
// CHECK-NEXT:     return opratorAnd1(a);
// CHECK-NEXT: }
