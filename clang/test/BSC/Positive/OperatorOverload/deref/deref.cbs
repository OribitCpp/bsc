// RUN: %clang %s -o %test.output
// RUN: %test.output
// RUN: %clang -rewrite-bsc %s -o %t-rw.c
// RUN: FileCheck --input-file=%t-rw.c %s
// RUN: %clang %t-rw.c -o %t-rw.output
// RUN: %t-rw.output
// expected-no-diagnostics

#include <stdlib.h>
// raw point parameter
struct E {
    int a;
};

struct F {
    struct E e;
};

__attribute__((operator *))
int *deref1(struct F * f) {
    return &(f->e.a);
}

int test1() {
    struct E e1 = {1};
    struct F f1 = {e1};
    int t1 = *f1;
    if (t1 != 1) {
        return -1;
    }
    *f1 = 2;
    if (*f1 != 2) {
        return -1;
    }
    return 0;
}

// borrow point parameter
struct G {
    int a;
};

struct H {
    struct G g;
    int b;
};

__attribute__((operator *))
safe int * borrow deref2(struct H * borrow h) {
    return &mut(h->g.a);
}

int test2() {
    struct G g1 = {1};
    struct H h1 = {g1, 11};
    safe {
        int t2 = *h1;
        if (t2 != 1) {
            return -1;
        }
        *h1 = 2;
        if (*h1 != 2) {
            return -1;
        }
    }

    return 0;
}

// const borrow point parameter
struct I {
    int a;
};

struct J {
    struct I i;
    int b;
};

__attribute__((operator *))
safe const int * borrow deref4(const struct J * borrow j) {
    return &const(j->i.a);
}

int test3() {
    struct I i1 = {1};
    struct J j1 = {i1, 11};
    safe {
        int t2 = *j1;
        if (t2 != 1) {
            return -1;
        }
    }
    return 0;
}
// Rc
struct RcData<T> {
	T data;
};
owned struct Rc<T> {
public:
  RcData<T> * ptr;
};

safe Rc<T> Rc<T>::new(T data) {
    unsafe {
        struct RcData<T> * RcDataPtr = (struct RcData<T> *)malloc(sizeof(struct RcData<T>));
        RcDataPtr->data = data;
        Rc<T> rc = { .ptr = RcDataPtr };
        return rc;
    }
}

__attribute__((operator *))
T* borrow deref<T>(Rc<T> * borrow rc) {
	return &mut(rc->ptr->data);
}

int test4() {
	Rc<int> rc = Rc<int>::new(5);
    if (*rc != 5) {
        return -1;
    }
	*rc = 6;
    if (*rc != 6) {
        return -1;
    }
    return 0;
}
// struct include Rc
owned struct RcRecord<T>
{
public:
    Rc<T> rc;
};

__attribute__((operator *))
Rc<T> deref5<T>(RcRecord<T> *rcRecord) {
	return rcRecord->rc;
}

int test5() {
    Rc<int> rc1 = Rc<int>::new(5);
    RcRecord<int> rcRecord = {rc1};
    Rc<int> rc2 = *rcRecord;
    int b = *rc2;
    // int c = **rcRecord;  // FIXME: error in source to source, "cannot take the address of an rvalue of type 'struct Rc_int'"
    return 0;
}

int main() {
    if (test1() || test2() || test3() || test4() || test5()) {
        return -1;
    }
    return 0;
}

// CHECK: #include <stdlib.h>
// CHECK-EMPTY: 
// CHECK-EMPTY: 
// CHECK:      struct E;
// CHECK-NEXT: struct F;
// CHECK-NEXT: struct G;
// CHECK-NEXT: struct H;
// CHECK-NEXT: struct I;
// CHECK-NEXT: struct J;
// CHECK-NEXT: struct RcData_int;
// CHECK-NEXT: struct Rc_int;
// CHECK-NEXT: struct RcRecord_int;
// CHECK-DAG: struct E {
// CHECK-DAG-NEXT:     int a;
// CHECK-DAG-NEXT: };
// CHECK-DAG:      struct G {
// CHECK-DAG-NEXT:     int a;
// CHECK-DAG-NEXT: };
// CHECK-DAG:      struct I {
// CHECK-DAG-NEXT:     int a;
// CHECK-DAG-NEXT: };
// CHECK-DAG:      struct Rc_int {
// CHECK-DAG-NEXT:     struct RcData_int *ptr;
// CHECK-DAG-NEXT: };
// CHECK-DAG:      struct RcData_int {
// CHECK-DAG-NEXT:     int data;
// CHECK-DAG-NEXT: };
// CHECK-DAG:      struct F {
// CHECK-DAG-NEXT:     struct E e;
// CHECK-DAG-NEXT: };
// CHECK-DAG:      struct H {
// CHECK-DAG-NEXT:     struct G g;
// CHECK-DAG-NEXT:     int b;
// CHECK-DAG-NEXT: };
// CHECK-DAG:      struct J {
// CHECK-DAG-NEXT:     struct I i;
// CHECK-DAG-NEXT:     int b;
// CHECK-DAG-NEXT: };
// CHECK:      struct RcRecord_int {
// CHECK-NEXT:      struct Rc_int rc;
// CHECK-NEXT: };
// CHECK-EMPTY: 
// CHECK:      static  struct Rc_int struct_Rc_int_new(int data);
// CHECK-EMPTY: 
// CHECK:      static void struct_Rc_int_D( struct Rc_int this);
// CHECK-EMPTY: 
// CHECK:      static int * deref_int( struct Rc_int * rc);
// CHECK-EMPTY: 
// CHECK:      static void struct_RcRecord_int_D( struct RcRecord_int this);
// CHECK-EMPTY: 
// CHECK:      static  struct Rc_int deref5_int( struct RcRecord_int *rcRecord);
// CHECK-EMPTY: 
// CHECK:      int *deref1(struct F *f) {
// CHECK-NEXT:     return &(f->e.a);
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      int test1(void) {
// CHECK-NEXT:     struct E e1 = {1};
// CHECK-NEXT:     struct F f1 = {e1};
// CHECK-NEXT:     int t1 = (*deref1(&f1));
// CHECK-NEXT:     if (t1 != 1) {
// CHECK-NEXT:         return -1;
// CHECK-NEXT:     }
// CHECK-NEXT:     (*deref1(&f1)) = 2;
// CHECK-NEXT:     if ((*deref1(&f1)) != 2) {
// CHECK-NEXT:         return -1;
// CHECK-NEXT:     }
// CHECK-NEXT:     return 0;
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      int * deref2(struct H * h) {
// CHECK-NEXT:     return &(h->g.a);
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      int test2(void) {
// CHECK-NEXT:     struct G g1 = {1};
// CHECK-NEXT:     struct H h1 = {g1, 11};
// CHECK-NEXT:     {
// CHECK-NEXT:         int t2 = (*deref2(&h1));
// CHECK-NEXT:         if (t2 != 1) {
// CHECK-NEXT:             return -1;
// CHECK-NEXT:         }
// CHECK-NEXT:         (*deref2(&h1)) = 2;
// CHECK-NEXT:         if ((*deref2(&h1)) != 2) {
// CHECK-NEXT:             return -1;
// CHECK-NEXT:         }
// CHECK-NEXT:     }
// CHECK-NEXT:     return 0;
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      const int * deref4(const struct J * j) {
// CHECK-NEXT:     return &(j->i.a);
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      int test3(void) {
// CHECK-NEXT:     struct I i1 = {1};
// CHECK-NEXT:     struct J j1 = {i1, 11};
// CHECK-NEXT:     {
// CHECK-NEXT:         int t2 = (*deref4(&j1));
// CHECK-NEXT:         if (t2 != 1) {
// CHECK-NEXT:             return -1;
// CHECK-NEXT:         }
// CHECK-NEXT:     }
// CHECK-NEXT:     return 0;
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      int test4(void) {
// CHECK-NEXT:      struct Rc_int rc = struct_Rc_int_new(5);
// CHECK-NEXT:     _Bool rc_is_moved = 0;
// CHECK-NEXT:     if ((*deref_int(&rc)) != 5) {
// CHECK-NEXT:         if (!rc_is_moved)
// CHECK-NEXT:             struct_Rc_int_D(rc);
// CHECK-NEXT:         return -1;
// CHECK-NEXT:     }
// CHECK-NEXT:     (*deref_int(&rc)) = 6;
// CHECK-NEXT:     if ((*deref_int(&rc)) != 6) {
// CHECK-NEXT:         if (!rc_is_moved)
// CHECK-NEXT:             struct_Rc_int_D(rc);
// CHECK-NEXT:         return -1;
// CHECK-NEXT:     }
// CHECK-NEXT:     if (!rc_is_moved)
// CHECK-NEXT:         struct_Rc_int_D(rc);
// CHECK-NEXT:     return 0;
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      int test5(void) {
// CHECK-NEXT:      struct Rc_int rc1 = struct_Rc_int_new(5);
// CHECK-NEXT:     _Bool rc1_is_moved = 0;
// CHECK-NEXT:      struct RcRecord_int rcRecord = {rc1};
// CHECK-NEXT:     _Bool rcRecord_is_moved = 0;
// CHECK-NEXT:     rc1_is_moved = 1;
// CHECK-NEXT:      struct Rc_int rc2 = deref5_int(&rcRecord);
// CHECK-NEXT:     _Bool rc2_is_moved = 0;
// CHECK-NEXT:     int b = (*deref_int(&rc2));
// CHECK-NEXT:     if (!rc2_is_moved)
// CHECK-NEXT:         struct_Rc_int_D(rc2);
// CHECK-NEXT:     if (!rcRecord_is_moved)
// CHECK-NEXT:         struct_RcRecord_int_D(rcRecord);
// CHECK-NEXT:     if (!rc1_is_moved)
// CHECK-NEXT:         struct_Rc_int_D(rc1);
// CHECK-NEXT:     return 0;
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      int main() {
// CHECK-NEXT:     if (test1() || test2() || test3() || test4() || test5()) {
// CHECK-NEXT:         return -1;
// CHECK-NEXT:     }
// CHECK-NEXT:     return 0;
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      static  struct Rc_int struct_Rc_int_new(int data) {
// CHECK-NEXT:     {
// CHECK-NEXT:         struct RcData_int *RcDataPtr = (struct RcData_int *)malloc(sizeof(struct RcData_int));
// CHECK-NEXT:         RcDataPtr->data = data;
// CHECK-NEXT:          struct Rc_int rc = {.ptr = RcDataPtr};
// CHECK-NEXT:         _Bool rc_is_moved = 0;
// CHECK-NEXT:         return rc;
// CHECK-NEXT:     }
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      static void struct_Rc_int_D( struct Rc_int this) {
// CHECK-NEXT:     _Bool this_is_moved = 0;
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      static int * deref_int( struct Rc_int * rc) {
// CHECK-NEXT:     return &(rc->ptr->data);
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      static void struct_RcRecord_int_D( struct RcRecord_int this) {
// CHECK-NEXT:     _Bool this_is_moved = 0;
// CHECK-NEXT:     struct_Rc_int_D(this.rc);
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      static  struct Rc_int deref5_int( struct RcRecord_int *rcRecord) {
// CHECK-NEXT:     return rcRecord->rc;
// CHECK-NEXT: }
// CHECK-EMPTY: 
