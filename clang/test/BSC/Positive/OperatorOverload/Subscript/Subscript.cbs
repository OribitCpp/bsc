// RUN: %clang %s -o %test.output
// RUN: %test.output
// RUN: %clang -rewrite-bsc %s -o %t-rw.c
// RUN: FileCheck --input-file=%t-rw.c %s
// RUN: %clang %t-rw.c -o %t-rw.output
// RUN: %t-rw.output
// expected-no-diagnostics

#include <stdlib.h>
// raw point parameter
struct E {
    int a;
};

struct F {
    struct E e[10];
};

__attribute__((operator []))
int *deref1(struct F * f, int i) {
    return &(f->e[i].a);
}

int test1() {
    struct E e1 = {1};
    struct F f1 = {e1};
    int t1 = f1[0];
    if (t1 != 1) {
        return -1;
    }
    f1[0] = 2;
    if (f1[0] != 2) {
        return -1;
    }
    for(int i = 0; i < 10; i++) {
        f1[i] = i;
    }
    int count = 0;
    for(int i = 0; i < 10; i++) {
        count += f1[i];
    }
    if (count != 45) {
        return -1;
    }
    return 0;
}

// borrow point parameter
struct G {
    int a;
};

struct H {
    struct G g[10];
    int b;
};

__attribute__((operator []))
safe int * borrow deref2(struct H * borrow h, int i) {
    return &mut(h->g[i].a);
}

int test2() {
    struct G g1 = {3};
    struct H h1 = {g1, 11};
    safe {
        int t2 = h1[0];
        if (t2 != 3) {
            return -1;
        }
        h1[0] = 2;
        if (h1[0] != 2) {
            return -1;
        }
    }
    return 0;
}

// const borrow point parameter
struct I {
    int a;
};

struct J {
    struct I i[10];
    int b;
};

__attribute__((operator []))
safe const int * borrow deref3(const struct J * borrow j, int n) {
    return &const(j->i[n].a);
}

int test3() {
    struct I i1 = {1};
    struct J j1 = {i1, 11};
    safe {
        int t2 = j1[0];
        if (t2 != 1) {
            return -1;
        }
    }
    return 0;
}

struct K {
    int a;
};

struct L {
    struct K g[10];
    int b;
};

__attribute__((operator []))
safe struct K * borrow deref4(struct L * borrow h, int i) {
    return &mut(h->g[i]);
}

int test4() {
    struct K k1 = {3};
    struct L l1 = {k1, 11};
    safe {
        int t2 = l1[0].a;
        if (t2 != 3) {
            return -1;
        }
        l1[0].a = 2;
        if (l1[0].a != 2) {
            return -1;
        }
    }
    return 0;
}
// Generic 
struct Data<T> {
	T data;
};

struct DataArray<T> {
  Data<T> array[10];
};

__attribute__((operator []))
struct Data<T> * borrow deref5<T>(struct DataArray<T> * borrow da, int i) {
    return &mut(da->array[i]);
}

int test5() {
    struct DataArray<int> dataArray;
    dataArray[0].data = 1;
    dataArray[1].data = 2;
    int data1 = dataArray[0].data;
    int data2 = dataArray[1].data;
    if (data1 + data2 != 3) {
        return -1;
    }
    return 0;
}

int main() {
    if (test1() || test2() || test3() || test4() || test5()) {
        return -1;
    }
    return 0;
}

// CHECK: #include <stdlib.h>
// CHECK-EMPTY: 
// CHECK-EMPTY: 
// CHECK:      struct E;
// CHECK-NEXT: struct F;
// CHECK-NEXT: struct G;
// CHECK-NEXT: struct H;
// CHECK-NEXT: struct I;
// CHECK-NEXT: struct J;
// CHECK-NEXT: struct K;
// CHECK-NEXT: struct L;
// CHECK-NEXT: struct Data_int;
// CHECK-NEXT: struct DataArray_int;
// CHECK-NEXT: struct E {
// CHECK-NEXT:     int a;
// CHECK-NEXT: };
// CHECK-EMPTY: 
// CHECK:      struct G {
// CHECK-NEXT:     int a;
// CHECK-NEXT: };
// CHECK-EMPTY: 
// CHECK:      struct I {
// CHECK-NEXT:     int a;
// CHECK-NEXT: };
// CHECK-EMPTY: 
// CHECK:      struct K {
// CHECK-NEXT:     int a;
// CHECK-NEXT: };
// CHECK-EMPTY: 
// CHECK:      struct Data_int {
// CHECK-NEXT:     int data;
// CHECK-NEXT: };
// CHECK-EMPTY: 
// CHECK:      struct F {
// CHECK-NEXT:     struct E e[10];
// CHECK-NEXT: };
// CHECK-EMPTY: 
// CHECK:      struct H {
// CHECK-NEXT:     struct G g[10];
// CHECK-NEXT:     int b;
// CHECK-NEXT: };
// CHECK-EMPTY: 
// CHECK:      struct J {
// CHECK-NEXT:     struct I i[10];
// CHECK-NEXT:     int b;
// CHECK-NEXT: };
// CHECK-EMPTY: 
// CHECK:      struct L {
// CHECK-NEXT:     struct K g[10];
// CHECK-NEXT:     int b;
// CHECK-NEXT: };
// CHECK-EMPTY: 
// CHECK:      struct DataArray_int {
// CHECK-NEXT:     struct Data_int array[10];
// CHECK-NEXT: };
// CHECK-EMPTY: 
// CHECK:      static struct Data_int * deref5_int(struct DataArray_int * da, int i);
// CHECK-EMPTY: 
// CHECK:      int *deref1(struct F *f, int i) {
// CHECK-NEXT:     return &(f->e[i].a);
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      int test1(void) {
// CHECK-NEXT:     struct E e1 = {1};
// CHECK-NEXT:     struct F f1 = {e1};
// CHECK-NEXT:     int t1 = (*deref1(&f1, 0));
// CHECK-NEXT:     if (t1 != 1) {
// CHECK-NEXT:         return -1;
// CHECK-NEXT:     }
// CHECK-NEXT:     (*deref1(&f1, 0)) = 2;
// CHECK-NEXT:     if ((*deref1(&f1, 0)) != 2) {
// CHECK-NEXT:         return -1;
// CHECK-NEXT:     }
// CHECK-NEXT:     for (int i = 0; i < 10; i++) {
// CHECK-NEXT:         (*deref1(&f1, i)) = i;
// CHECK-NEXT:     }
// CHECK-NEXT:     int count = 0;
// CHECK-NEXT:     for (int i = 0; i < 10; i++) {
// CHECK-NEXT:         count += (*deref1(&f1, i));
// CHECK-NEXT:     }
// CHECK-NEXT:     if (count != 45) {
// CHECK-NEXT:         return -1;
// CHECK-NEXT:     }
// CHECK-NEXT:     return 0;
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      int * deref2(struct H * h, int i) {
// CHECK-NEXT:     return &(h->g[i].a);
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      int test2(void) {
// CHECK-NEXT:     struct G g1 = {3};
// CHECK-NEXT:     struct H h1 = {g1, 11};
// CHECK-NEXT:     {
// CHECK-NEXT:         int t2 = (*deref2(&h1, 0));
// CHECK-NEXT:         if (t2 != 3) {
// CHECK-NEXT:             return -1;
// CHECK-NEXT:         }
// CHECK-NEXT:         (*deref2(&h1, 0)) = 2;
// CHECK-NEXT:         if ((*deref2(&h1, 0)) != 2) {
// CHECK-NEXT:             return -1;
// CHECK-NEXT:         }
// CHECK-NEXT:     }
// CHECK-NEXT:     return 0;
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      const int * deref3(const struct J * j, int n) {
// CHECK-NEXT:     return &(j->i[n].a);
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      int test3(void) {
// CHECK-NEXT:     struct I i1 = {1};
// CHECK-NEXT:     struct J j1 = {i1, 11};
// CHECK-NEXT:     {
// CHECK-NEXT:         int t2 = (*deref3(&j1, 0));
// CHECK-NEXT:         if (t2 != 1) {
// CHECK-NEXT:             return -1;
// CHECK-NEXT:         }
// CHECK-NEXT:     }
// CHECK-NEXT:     return 0;
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      struct K * deref4(struct L * h, int i) {
// CHECK-NEXT:     return &(h->g[i]);
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      int test4(void) {
// CHECK-NEXT:     struct K k1 = {3};
// CHECK-NEXT:     struct L l1 = {k1, 11};
// CHECK-NEXT:     {
// CHECK-NEXT:         int t2 = (*deref4(&l1, 0)).a;
// CHECK-NEXT:         if (t2 != 3) {
// CHECK-NEXT:             return -1;
// CHECK-NEXT:         }
// CHECK-NEXT:         (*deref4(&l1, 0)).a = 2;
// CHECK-NEXT:         if ((*deref4(&l1, 0)).a != 2) {
// CHECK-NEXT:             return -1;
// CHECK-NEXT:         }
// CHECK-NEXT:     }
// CHECK-NEXT:     return 0;
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      int test5(void) {
// CHECK-NEXT:     struct DataArray_int dataArray;
// CHECK-NEXT:     (*deref5_int(&dataArray, 0)).data = 1;
// CHECK-NEXT:     (*deref5_int(&dataArray, 1)).data = 2;
// CHECK-NEXT:     int data1 = (*deref5_int(&dataArray, 0)).data;
// CHECK-NEXT:     int data2 = (*deref5_int(&dataArray, 1)).data;
// CHECK-NEXT:     if (data1 + data2 != 3) {
// CHECK-NEXT:         return -1;
// CHECK-NEXT:     }
// CHECK-NEXT:     return 0;
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      int main() {
// CHECK-NEXT:     if (test1() || test2() || test3() || test4() || test5()) {
// CHECK-NEXT:         return -1;
// CHECK-NEXT:     }
// CHECK-NEXT:     return 0;
// CHECK-NEXT: }
// CHECK-EMPTY: 
// CHECK:      static struct Data_int * deref5_int(struct DataArray_int * da, int i) {
// CHECK-NEXT:     return &(da->array[i]);
// CHECK-NEXT: }
// CHECK-EMPTY: 
