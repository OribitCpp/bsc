// RUN: %clang %s -o %test.output
// RUN: %test.output
// RUN: %clang -rewrite-bsc %s -o %t-rw.c
// RUN: FileCheck --input-file=%t-rw.c %s
// RUN: %clang %t-rw.c -o %t-rw.output
// RUN: %t-rw.output


owned struct S {
public:
    int a;
    char* c;
    ~S(S this) {}
};

void use(S s) {}

void move_only() {
  S s1 = {1, "s1"};
  S s2 = s1;
  S s3 = s2;
}

void field_var_assign() {
  S s1 = {1, "s1"};
  S s2 = {2, "s2"};
  s2.a = s1.a;
}

void reassign_and_move() {
  S s1 = {1, "s1"};
  S s2 = {2, "s2"};
  s2 = s1;
}

void reassign_after_move() {
  S s1 = {1, "s1"};
  S s2 = {2, "s2"};
  use(s2);
  s2 = s1;
}

void reassign_in_if() {
  S s1 = {1, "s1"};
  S s2 = {2, "s2"};
  if (1) {
    use(s2);
  } else {
    s2 = s1;
  }
  
}

int main() {
  return 0;
}

// CHECK: static void struct_S_D( struct S this);

// CHECK: void use( struct S s) {
// CHECK-NEXT:     _Bool s_is_moved = 0;
// CHECK-NEXT:     if (!s_is_moved)
// CHECK-NEXT:         struct_S_D(s);
// CHECK-NEXT: }

// CHECK: void move_only(void) {
// CHECK-NEXT:      struct S s1 = {1, "s1"};
// CHECK-NEXT:     _Bool s1_is_moved = 0;
// CHECK-NEXT:      struct S s2 = s1;
// CHECK-NEXT:     _Bool s2_is_moved = 0;
// CHECK-NEXT:     s1_is_moved = 1;
// CHECK-NEXT:      struct S s3 = s2;
// CHECK-NEXT:     _Bool s3_is_moved = 0;
// CHECK-NEXT:     s2_is_moved = 1;
// CHECK-NEXT:     if (!s3_is_moved)
// CHECK-NEXT:         struct_S_D(s3);
// CHECK-NEXT:     if (!s2_is_moved)
// CHECK-NEXT:         struct_S_D(s2);
// CHECK-NEXT:     if (!s1_is_moved)
// CHECK-NEXT:         struct_S_D(s1);
// CHECK-NEXT: }

// CHECK: void field_var_assign(void) {
// CHECK-NEXT:      struct S s1 = {1, "s1"};
// CHECK-NEXT:     _Bool s1_is_moved = 0;
// CHECK-NEXT:      struct S s2 = {2, "s2"};
// CHECK-NEXT:     _Bool s2_is_moved = 0;
// CHECK-NEXT:     s2.a = s1.a;
// CHECK-NEXT:     if (!s2_is_moved)
// CHECK-NEXT:         struct_S_D(s2);
// CHECK-NEXT:     if (!s1_is_moved)
// CHECK-NEXT:         struct_S_D(s1);
// CHECK-NEXT: }

// CHECK: void reassign_and_move(void) {
// CHECK-NEXT:      struct S s1 = {1, "s1"};
// CHECK-NEXT:     _Bool s1_is_moved = 0;
// CHECK-NEXT:      struct S s2 = {2, "s2"};
// CHECK-NEXT:     _Bool s2_is_moved = 0;
// CHECK-NEXT:     if (!s2_is_moved)
// CHECK-NEXT:         struct_S_D(s2);
// CHECK-NEXT:     s2 = s1;
// CHECK-NEXT:     s2_is_moved = 0;
// CHECK-NEXT:     s1_is_moved = 1;
// CHECK-NEXT:     if (!s2_is_moved)
// CHECK-NEXT:         struct_S_D(s2);
// CHECK-NEXT:     if (!s1_is_moved)
// CHECK-NEXT:         struct_S_D(s1);
// CHECK-NEXT: }

// CHECK: void reassign_after_move(void) {
// CHECK-NEXT:      struct S s1 = {1, "s1"};
// CHECK-NEXT:     _Bool s1_is_moved = 0;
// CHECK-NEXT:      struct S s2 = {2, "s2"};
// CHECK-NEXT:     _Bool s2_is_moved = 0;
// CHECK-NEXT:     use(s2);
// CHECK-NEXT:     s2_is_moved = 1;
// CHECK-NEXT:     if (!s2_is_moved)
// CHECK-NEXT:         struct_S_D(s2);
// CHECK-NEXT:     s2 = s1;
// CHECK-NEXT:     s2_is_moved = 0;
// CHECK-NEXT:     s1_is_moved = 1;
// CHECK-NEXT:     if (!s2_is_moved)
// CHECK-NEXT:         struct_S_D(s2);
// CHECK-NEXT:     if (!s1_is_moved)
// CHECK-NEXT:         struct_S_D(s1);
// CHECK-NEXT: }

// CHECK: void reassign_in_if(void) {
// CHECK-NEXT:      struct S s1 = {1, "s1"};
// CHECK-NEXT:     _Bool s1_is_moved = 0;
// CHECK-NEXT:      struct S s2 = {2, "s2"};
// CHECK-NEXT:     _Bool s2_is_moved = 0;
// CHECK-NEXT:     if (1) {
// CHECK-NEXT:         use(s2);
// CHECK-NEXT:         s2_is_moved = 1;
// CHECK-NEXT:     } else {
// CHECK-NEXT:         if (!s2_is_moved)
// CHECK-NEXT:             struct_S_D(s2);
// CHECK-NEXT:         s2 = s1;
// CHECK-NEXT:         s2_is_moved = 0;
// CHECK-NEXT:         s1_is_moved = 1;
// CHECK-NEXT:     }
// CHECK-NEXT:     if (!s2_is_moved)
// CHECK-NEXT:         struct_S_D(s2);
// CHECK-NEXT:     if (!s1_is_moved)
// CHECK-NEXT:         struct_S_D(s1);
// CHECK-NEXT: }