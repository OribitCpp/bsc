// RUN: %clang %s -o %test.output
// RUN: %test.output
// RUN: %clang -rewrite-bsc %s -o %t-rw.c
// RUN: %clang %t-rw.c -o %t-rw.output
// RUN: %t-rw.output

#include <stdio.h>

owned struct Person{
public:
    int age;
    ~Person(Person this) {
    }
};

// nested owned struct
owned struct Student{
public:
    int score;
    Person p;
    ~Student(This this) {
    }
};

// generic case
owned struct Person2<T>{
public:
    T age;
    ~Person2(This this) {
        printf("P2 age = %d\n", this.age); // print P2 age = **
    }
};

// nested owned struct and generic case 1
owned struct Student2<T>{
public:
    T score;
    Person p;
    ~Student2(This this) {
        printf("S2 score = %d, S2 age = %d\n", this.score, this.p.age); // print S2 score = 80, S2 age = 22
    }
};

// nested owned struct and generic case 2
owned struct Student3<T1, T2>{
public:
    T1 score;
    Person2<T2> p;
    ~Student3(This this) {
        printf("S3 score = %d, S3 age = %d\n", this.score, this.p.age); // print S3 score = 90, S3 age = 23
    }
};

// Constant generic
owned struct Student4<T, int N>{
public:
    T scores[N];
    Person p;
    ~Student4(This this) {
        printf("S4 score = %d, S4 age = %d\n", this.scores[0], this.p.age); // print S4 score = 100, S4 age = 25
    }
};


int main() {
    Person per = {.age = 20};

    Student stu = {.score = 100, .p = per};
    stu.p.age = 25;

    Person2<int> per2 = {.age = 21};

    // .p cannot use per again, because per is released in stu
    Student2<int> stu2 = {.score = 80, .p = {22}};

    Student3<int, int> stu3 = {.score = 90, .p = {23}};
    
    Student4<int, 3> stu4 = {.scores = {100, 20, 30}, .p = {25}};

    return 0;
}
