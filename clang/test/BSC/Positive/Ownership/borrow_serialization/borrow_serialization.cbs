// RUN: %clang %s -o %t.output
// RUN: %t.output
// expected-no-diagnostics

// RUN: %clang -rewrite-bsc %s -o %t-rw.c
// RUN: %clang %t-rw.c -o %t-rw.output
// RUN: %t-rw.output

// Test with serialization:
// RUN: %clang_cc1 -triple x86_64-unknown-unknown -emit-pch -o %t %s
// RUN: %clang_cc1 -x bsc -triple x86_64-unknown-unknown -include-pch %t -ast-dump-all /dev/null \
// RUN: | sed -e "s/ <undeserialized declarations>//" -e "s/ imported//" \
// RUN: | FileCheck --strict-whitespace %s

struct R {
  int *borrow p1;
  const int *borrow p2;
};

void int::foo(This *borrow this) {}

typedef int *borrow myInt;
typedef int *borrow (*PF2)(struct R);

void test() {
  int x1 = 0;
  int x = 0;
  float y = 1.0;
  const int *borrow p4= (const int *borrow)&x;
  const int *borrow p2 = &const x;
  int *borrow p7 = &mut *(&x);
  int *borrow p = &mut x;
  float *borrow p1 = &mut y;
  myInt p3 = p;

  int *owned p5 = (int *owned)&x1;
  const int *borrow b6 = &const *p3;
  p7 = &mut *p;
  int *p8 = (int *)p5;
}

int main() {
    return 0;
}

// CHECK: FunctionDecl 0x{{[^ ]*}} <line:[[@LINE-21]]:1, line:[[@LINE-6]]:1> line:[[@LINE-21]]:6 test 'void (void)'
// CHECK-NEXT: CompoundStmt 0x{{[^ ]*}} <col:13, line:[[@LINE-7]]:1>
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-22]]:3, col:13>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:12> col:7 used x1 'int' cinit
// CHECK-NEXT: IntegerLiteral 0x{{[^ ]*}} <col:12> 'int' 0
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-24]]:3, col:12>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:11> col:7 used x 'int' cinit
// CHECK-NEXT: IntegerLiteral 0x{{[^ ]*}} <col:11> 'int' 0
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-26]]:3, col:16>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:13> col:9 used y 'float' cinit
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:13> 'float' <FloatingCast>
// CHECK-NEXT: FloatingLiteral 0x{{[^ ]*}} <col:13> 'double' 1.000000e+00
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-29]]:3, col:46>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:45> col:21 p4 'const int *borrow' cinit
// CHECK-NEXT: CStyleCastExpr 0x{{[^ ]*}} <col:25, col:45> 'const int *borrow' <NoOp>
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <col:44, col:45> 'int *' prefix '&' cannot overflow
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:45> 'int' lvalue Var 0x{{[^ ]*}} 'x' 'int'
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-33]]:3, col:34>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:33> col:21 p2 'const int *borrow' cinit
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <col:26, col:33> 'const int *borrow' prefix '&' cannot overflow
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:33> 'int' lvalue Var 0x{{[^ ]*}} 'x' 'int'
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-36]]:3, col:30>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:29> col:15 used p7 'int *borrow' cinit
// CHECK-NEXT: ParenExpr 0x{{[^ ]*}} <col:26, col:29> 'int *'
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <col:27, col:28> 'int *' prefix '&' cannot overflow
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:28> 'int' lvalue Var 0x{{[^ ]*}} 'x' 'int'
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-40]]:3, col:25>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:24> col:15 used p 'int *borrow' cinit
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <col:19, col:24> 'int *borrow' prefix '&' cannot overflow
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:24> 'int' lvalue Var 0x{{[^ ]*}} 'x' 'int'
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-43]]:3, col:28>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:27> col:17 p1 'float *borrow' cinit
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <col:22, col:27> 'float *borrow' prefix '&' cannot overflow
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:27> 'float' lvalue Var 0x{{[^ ]*}} 'y' 'float'
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-46]]:3, col:15>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:14> col:9 used p3 'myInt':'int *borrow' cinit
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:14> 'int *borrow' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:14> 'int *borrow' lvalue Var 0x{{[^ ]*}} 'p' 'int *borrow'
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-48]]:3, col:34>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:32> col:14 used p5 'int *owned' cinit
// CHECK-NEXT: CStyleCastExpr 0x{{[^ ]*}} <col:19, col:32> 'int *owned' <NoOp>
// CHECK-NEXT: UnaryOperator 0x{{[^ ]*}} <col:31, col:32> 'int *' prefix '&' cannot overflow
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:32> 'int' lvalue Var 0x{{[^ ]*}} 'x1' 'int'
// CHECK-NEXT: DeclStmt 0x{{[^ ]*}} <line:[[@LINE-52]]:3, col:36>
// CHECK-NEXT: VarDecl 0x{{[^ ]*}} <col:3, col:34> col:21 b6 'const int *borrow' cinit
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:34> 'int *borrow' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:34> 'myInt':'int *borrow' lvalue Var 0x{{[^ ]*}} 'p3' 'myInt':'int *borrow'
// CHECK-NEXT: BinaryOperator 0x{{[^ ]*}} <line:[[@LINE-55]]:3, col:14> 'int *borrow' '='
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:3> 'int *borrow' lvalue Var 0x{{[^ ]*}} 'p7' 'int *borrow'
// CHECK-NEXT: ImplicitCastExpr 0x{{[^ ]*}} <col:14> 'int *borrow' <LValueToRValue>
// CHECK-NEXT: DeclRefExpr 0x{{[^ ]*}} <col:14> 'int *borrow' lvalue Var 0x{{[^ ]*}} 'p' 'int *borrow'