// RUN: %clang %s -o %test.output
// RUN: %test.output
// RUN: %clang -rewrite-bsc %s -o %t-rw.c
// RUN: %clang %t-rw.c -o %t-rw.output
// RUN: %t-rw.output
// RUN: %clang -rewrite-bsc -line %s -o %t-rwline.c
// RUN: FileCheck --input-file=%t-rwline.c %s --check-prefix=CHECK-L
// expected-no-diagnostics

#include <stdlib.h>
void use_mut(int *borrow p) {}
void use_immut(const int *borrow p) {}

T* owned safe_malloc<T>(T value) {
  T * p = (T *) malloc( sizeof(T) );
  *p = value;
  return (T* owned)p;
}

void free_owned<T>(T* owned p) {
  free( (T*)p );
}

void test1() {
  int *oriPtr = malloc(sizeof(int));
  int *borrow p1 = &mut * oriPtr;
  const int *borrow p2 = &const * oriPtr;
  int *borrow p3 = &mut * oriPtr;
  use_mut(p3);
  // use_immut(p2);
  // use_mut(p1);  
  free(oriPtr);
}

void test2() {
  int *owned oriPtr = safe_malloc<int>(0);
  const int *borrow p1 = &const * oriPtr;
  const int *borrow p2 = &const * oriPtr;
  use_immut(p1);
  use_immut(p2);
  free_owned<int>(oriPtr);
}

void test3() {
  int a = 5;
  int b = 5, c = 5;
  int *owned oriPtr = safe_malloc<int>(0);
  int *borrow p1 = &mut a;
  int *borrow p2 = &mut b;
  if (c > 0)
    p1 = &mut * oriPtr;
  else 
    p2 = &mut * oriPtr;
  use_mut(p1);
  use_mut(p2);
  free_owned<int>(oriPtr);
}

void test4() {
  int a = 5;
  int b = 5;
  int *owned oriPtr = safe_malloc<int>(0);
  int *borrow p1 = &mut a;
  int *borrow p2 = &mut b;
  if (1) {
    p2 = &mut * oriPtr;
    p1 = &mut * oriPtr;  
  } else {  // Dead Code
    p2 = &mut * oriPtr;  
    p1 = &mut * oriPtr;
  }
  use_mut(p1);
  // use_mut(p2);
  free_owned<int>(oriPtr);
}

int* borrow use_borrow_and_return(int *borrow p) {
  return p;
}
void test5() {
  int local = 42;
  int *borrow p1 = &mut local;
  int *borrow p2 = use_borrow_and_return(p1);
  use_mut(p2);
  // use_mut(p1);
}


// CHECK-L: #line 11 "{{.*}}.cbs"
// CHECK-L-NEXT: void use_mut(int * p) {
// CHECK-L-NEXT: }

// CHECK-L: #line 12 "{{.*}}.cbs"
// CHECK-L-NEXT: void use_immut(const int * p) {
// CHECK-L-NEXT: }

// CHECK-L: #line 24 "{{.*}}.cbs"
// CHECK-L-NEXT: void test1(void) {
// CHECK-L-NEXT:   int *oriPtr = malloc(sizeof(int));
// CHECK-L-NEXT:   int * p1 = &*oriPtr;
// CHECK-L-NEXT:   const int * p2 = &*oriPtr;
// CHECK-L-NEXT:   int * p3 = &*oriPtr;
// CHECK-L-NEXT:   use_mut(p3);
// CHECK-L-NEXT:   free(oriPtr);
// CHECK-L-NEXT: }

// CHECK-L: #line 35 "{{.*}}.cbs"
// CHECK-L-NEXT: void test2(void) {
// CHECK-L-NEXT:   int * oriPtr = safe_malloc_int(0);
// CHECK-L-NEXT:   const int * p1 = &*oriPtr;
// CHECK-L-NEXT:   const int * p2 = &*oriPtr;
// CHECK-L-NEXT:   use_immut(p1);
// CHECK-L-NEXT:   use_immut(p2);
// CHECK-L-NEXT:   free_owned_int(oriPtr);
// CHECK-L-NEXT: }

// CHECK-L: #line 44 "{{.*}}.cbs"
// CHECK-L-NEXT: void test3(void) {
// CHECK-L-NEXT:   int a = 5;
// CHECK-L-NEXT:   int b = 5, c = 5;
// CHECK-L-NEXT:   int * oriPtr = safe_malloc_int(0);
// CHECK-L-NEXT:   int * p1 = &a;
// CHECK-L-NEXT:   int * p2 = &b;
// CHECK-L-NEXT:   if (c > 0)
// CHECK-L-NEXT:     p1 = &*oriPtr;
// CHECK-L-NEXT:   else
// CHECK-L-NEXT:     p2 = &*oriPtr;
// CHECK-L-NEXT:   use_mut(p1);
// CHECK-L-NEXT:   use_mut(p2);
// CHECK-L-NEXT:   free_owned_int(oriPtr);
// CHECK-L-NEXT: }

// CHECK-L: #line 59 "{{.*}}.cbs"
// CHECK-L-NEXT: void test4(void) {
// CHECK-L-NEXT:   int a = 5;
// CHECK-L-NEXT:   int b = 5;
// CHECK-L-NEXT:   int * oriPtr = safe_malloc_int(0);
// CHECK-L-NEXT:   int * p1 = &a;
// CHECK-L-NEXT:   int * p2 = &b;
// CHECK-L-NEXT:   if (1) {
// CHECK-L-NEXT:     p2 = &*oriPtr;
// CHECK-L-NEXT:     p1 = &*oriPtr;
// CHECK-L-NEXT:   } else {
// CHECK-L-NEXT:     p2 = &*oriPtr;
// CHECK-L-NEXT:     p1 = &*oriPtr;
// CHECK-L-NEXT:   }
// CHECK-L-NEXT:   use_mut(p1);
// CHECK-L-NEXT:   free_owned_int(oriPtr);
// CHECK-L-NEXT: }

// CHECK-L: #line 77 "{{.*}}.cbs"
// CHECK-L-NEXT: int * use_borrow_and_return(int * p) {
// CHECK-L-NEXT:   return p;
// CHECK-L-NEXT: }

// CHECK-L: #line 80 "{{.*}}.cbs"
// CHECK-L-NEXT: void test5(void) {
// CHECK-L-NEXT:   int local = 42;
// CHECK-L-NEXT:   int * p1 = &local;
// CHECK-L-NEXT:   int * p2 = use_borrow_and_return(p1);
// CHECK-L-NEXT:   use_mut(p2);
// CHECK-L-NEXT: }

int main() {
  test1();
  test2();
  test3();
  test4();
  test5();
  return 0;
}