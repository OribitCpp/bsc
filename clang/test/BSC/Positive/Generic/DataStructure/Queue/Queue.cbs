// RUN: %clang %s -o %t.output
// RUN: %t.output
// RUN: %clang -rewrite-bsc %s -o %t-rw.c
// RUN: %clang %t-rw.c -o %t-rw.output
// RUN: %t-rw.output
// expected-no-diagnostics

#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100
struct Queue<T> {
    T data[MAX_SIZE];
    int head;
    int rear;
};

void struct Queue<T>::init(struct Queue<T> *this) {
    this->head = this->rear = 0;
}

int struct Queue<T>::isEmpty(struct Queue<T> *this) {
    return this->head == this->rear;
}

int struct Queue<T>::isFull(struct Queue<T> *this) {
    return (this->rear + 1) % MAX_SIZE == this->head;
}

void struct Queue<T>::push(struct Queue<T> *this, T value) {
    if (this->isFull()) {
        printf("this queue is full!\n");
        exit(-1);
    }
    this->data[this->rear] = value;
    this->rear = (this->rear + 1) % MAX_SIZE;
}

T struct Queue<T>::pop(struct Queue<T> *this) {
    if (this->isEmpty()) {
        printf("this queue is empty!\n");
        exit(-1);
    }
    T value = this->data[this->head];
    this->head = (this->head + 1) % MAX_SIZE;
    return value;
}

T struct Queue<T>::front(struct Queue<T> *this) {
    if (this->isEmpty()) {
        printf("this queue is empty!\n");
        exit(-1);
    }
    return this->data[this->head];
}

T struct Queue<T>::back(struct Queue<T> *this) {
    if (this->isEmpty()) {
        printf("this queue is empty!\n");
        exit(-1);
    }
    return this->data[this->rear - 1];
}

int main() {
    struct Queue<int> q;
    q.init();
    for (int i = 0; i < 10; i++) {
        q.push(i);
    }
    printf("q.front: %d\n", q.front());
    printf("q.back: %d\n", q.back());
    while(!q.isEmpty()) {
        int value = q.pop();
        printf("%d ", value);
    }
    return 0;
}

