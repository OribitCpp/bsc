// RUN: %clang %s -o %t.output
// RUN: %t.output
// RUN: %clang -rewrite-bsc %s -o %t-rw.c
// RUN: %clang %t-rw.c -o %t-rw.output
// RUN: %t-rw.output
// RUN: %clang -rewrite-bsc -line %s -o %t-rwline.c
// RUN: FileCheck --input-file=%t-rwline.c %s --check-prefix=CHECK-L
// expected-no-diagnostics

struct S<T> {};
typedef MyS<T> = S<T>;
typedef MyS_int = S<int>;

union U<T> {};
typedef MyU<T> = U<T>;
typedef MyU_int = U<int>;

void S<T>::foo1(This* this) {}

void S<T>::foo2(S<T>* this) {}

S<T> S<T>::foo3(This* this, S<T> a) {
    return a;
}

void U<T>::foo1(This* this) {}

void U<T>::foo2(U<T>* this) {}

U<T> U<T>::foo3(This* this, U<T> a) {
    return a;
}

S<T> bar1<T>(S<T> a) {
    return a;
}

S<int> bar2(S<int> a) {
    return a;
}

U<T> bar3<T>(U<T> a) {
    return a;
}

U<int> bar4(U<int> a) {
    return a;
}

struct G<T> {
    S<T> a;
    U<T> b;
};

trait F {
    S<int> foo4(This* this);
    U<int> foo5(This* this);
};
struct P {
    S<int> a;
    U<int> b;
};
S<int> struct P::foo4(This* this) {
  return this->a;
}
U<int> struct P::foo5(This* this) {
  return this->b;
}
impl trait F for struct P;

// CHECK-L: #line 38 "{{.*}}.cbs"
// CHECK-L-NEXT: struct S_int bar2(struct S_int a) {
// CHECK-L-NEXT:   return a;
// CHECK-L-NEXT: }

// CHECK-L: #line 46 "{{.*}}.cbs"
// CHECK-L-NEXT: union U_int bar4(union U_int a) {
// CHECK-L-NEXT:   return a;
// CHECK-L-NEXT: }

// CHECK-L: #line 63 "{{.*}}.cbs"
// CHECK-L-NEXT: struct S_int struct_P_foo4(struct P *this) {
// CHECK-L-NEXT:   return this->a;
// CHECK-L-NEXT: }

// CHECK-L: #line 66 "{{.*}}.cbs"
// CHECK-L-NEXT: U_int struct_P_foo5(struct P *this) {
// CHECK-L-NEXT:   return this->b;
// CHECK-L-NEXT: }

// CHECK-L: #line 18 "{{.*}}.cbs"
// CHECK-L-NEXT: static void struct_S_int_foo1(struct S_int *this) {
// CHECK-L-NEXT: }

int main() {
    S<int> s1;
    s1.foo1();
    s1.foo2();
    S<int> s2 = s1.foo3(s1);
    S<int> s3 = bar1<int>(s1);
    S<int> s4 = bar2(s1);    
    
    U<int> u1;
    u1.foo1();
    u1.foo2();
    U<int> u2 = u1.foo3(u1);
    U<int> u3 = bar3<int>(u1);
    U<int> u4 = bar4(u1);  

    G<int> g1 = { .a = s1, .b = u1 };
    
    S<S<int>> s5;
    U<S<int>> u5;
    G<S<int>> g2 = { .a = s5, .b = u5 };
  
    struct P p = { .a = s1, .b = u1 };
    trait F* f = &p;
    f->foo4();
    f->foo5();

    MyS<int> s6;
    MyS_int s7;
    MyU<int> u6;
    MyU_int u7;
    return 0;
}